			+-------------------------+
			|        CS 318           |
			| PROJECT 0: Getting Real |
			|     DESIGN DOCUMENT     |
			+-------------------------+
				   
---- AUTHOR ----

>> Fill in your name and email address.
>>>>	name: Li Luoxuan
		email: chenyxuan@sjtu.edu.cn

FirstName LastName <email@domain.example>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

			     Booting Pintos
			     ==============

---- QUESTIONS ---- 
>> Put the screenshots of Pintos running in src/p0.
>> A1: Is there any particular issue that you would like us to know?
>>>> No.
			     Debugging
			     =========

---- QUESTIONS: BIOS ---- 
>> B1: What is the first instruction that gets executed?
>> B2: At which physical address is this instruction located?
>>>> 	[f000:fff0]    0xffff0:	ljmp   $0xf000,$0xe05b

>> B3: Can you guess why the first instruction is like this?
>>>> To make it easy to figure out the boundary between BIOS ROM and memory.

>> B4: What are the next three instructions?
>>>> 	[f000:e05b]    0xfe05b:	cmpl   $0x0,%cs:0x6c48
		[f000:e062]    0xfe062:	jne    0xfd2e1
		[f000:e066]    0xfe066:	xor    %dx,%dx


---- QUESTIONS: BOOTLOADER ---- 
>> B5: How does the bootloader read disk sectors? In particular, what BIOS interrupt
is used?
>>>>(1)	read_sector:
			pusha
			sub %ax, %ax
			push %ax			# LBA sector number [48:63]
			push %ax			# LBA sector number [32:47]
			push %ebx			# LBA sector number [0:31]
			push %es			# Buffer segment
			push %ax			# Buffer offset (always 0)
			push $1				# Number of sectors to read
			push $16			# Packet size
			mov $0x42, %ah			# Extended read
			mov %sp, %si			# DS:SI -> packet
			int $0x13			# Error code in CF
			popa				# Pop 16 bytes, preserve flags
	(2)	$0x13

>> B6: How does the bootloader decides whether it finds the Pintos kernel?
>>>> 	By running check_partition.

>> B7: What happens when the bootloader could not find the Pintos kernel?
>>>> 	It puts string "\rNot found\r" and interrupts with code $0x18 .

>> B8: At what point does the bootloader transfer control to the Pintos kernel?
>>>>	At the end of recognizing sectors.

---- QUESTIONS: KERNEL ---- 
>> B9: Is there any issue in particular that you would like us to know?
>>>> No.

			     Kernel Monitor
			     ==============

---- DATA STRUCTURES ----

>> C1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.
>>>>	......wtf?
		/* read a line from the buffer with a limited length. >_< */
		void readline(char *str, int max_length) {

		/* A tricky guess */
		#define CLOCKS_PER_SEC 100

---- ALGORITHMS ----
>> C2: Explain how you read and write to the console for the kernel monitor.
>>>>	By using putchar, puts, input_getc functions, simple but effective.

>> C3: Any additional enhancement you implement?
>>>>	A readline function.
